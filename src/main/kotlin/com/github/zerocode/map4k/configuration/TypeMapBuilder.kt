package com.github.zerocode.map4k.configuration

import com.github.zerocode.map4k.MappingException
import com.github.zerocode.map4k.extensions.returnTypeClass
import kotlin.reflect.KClass
import kotlin.reflect.KFunction1
import kotlin.reflect.KProperty1
import kotlin.reflect.full.createType
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.full.primaryConstructor
import kotlin.reflect.jvm.reflect

data class TypeMapBuilder(
    val sourceClass: KClass<*>,
    val targetClass: KClass<*>,
    val userDefinedPropertyMaps: List<PropertyMap> = emptyList()
) {
    inline fun <reified TSource : Any, reified TSourceReturn : Any, reified TTarget : Any, reified TTargetReturn> propertyMap(
        sourceProperty: KProperty1<TSource, TSourceReturn>,
        targetProperty: KProperty1<TTarget, TTargetReturn>
    ): TypeMapBuilder {
        return this.copy(
            userDefinedPropertyMaps = this.userDefinedPropertyMaps + PropertyMap(
                targetProperty = targetProperty,
                targetParameter = TTarget::class.primaryConstructor?.parameters?.first { it.name == targetProperty.name }!!,
                sourceResolution = NamedSourceResolution(sourceProperty),
                conversion = TypeConversions.noopConverter(sourceProperty.returnTypeClass, sourceProperty.returnType, targetProperty.returnTypeClass)
            ))
    }

    inline fun <reified TSource : Any, reified TSourceReturn : Any, reified TTarget : Any, reified TTargetReturn> propertyMap(
        sourceProperty: KProperty1<TSource, TSourceReturn>,
        targetProperty: KProperty1<TTarget, TTargetReturn>,
        noinline converter: Function1<TSourceReturn, TTargetReturn>
    ): TypeMapBuilder {
        return this.copy(
            userDefinedPropertyMaps = this.userDefinedPropertyMaps + PropertyMap(
                targetProperty = targetProperty,
                targetParameter = TTarget::class.primaryConstructor?.parameters?.first { it.name == targetProperty.name }!!,
                sourceResolution = ConvertedSourceResolution(
                    sourceProperty = sourceProperty
                ),
                conversion = SimpleTypeConverter(TSourceReturn::class, TTargetReturn::class, converter as (Any) -> Any)
            ))
    }

    inline fun <reified TSource : Any, reified TTarget : Any, reified TTargetReturn> propertyMap(
        targetProperty: KProperty1<TTarget, TTargetReturn>,
        noinline generator: Function1<TSource, TTargetReturn>
    ): TypeMapBuilder {
        return this.copy(
            userDefinedPropertyMaps = this.userDefinedPropertyMaps + PropertyMap(
                targetProperty = targetProperty,
                targetParameter = TTarget::class.primaryConstructor?.parameters?.first { it.name == targetProperty.name }!!,
                sourceResolution = GeneratedSourceResolution(generator = generator as Function1<Any?, *>),
                conversion = TypeConversions.noopConverter(TSource::class, TSource::class.createType(), targetProperty.returnTypeClass)
            ))
    }

    // TODO test & refactor
    fun build(
        typeConversions: TypeConversions = TypeConversions(),
        options: MappingOptions = MappingOptions()
    ): TypeMap {
        try {
            val generatedPropertyMaps = autoGeneratedPropertyMaps()
            val propertyMapsWithTypeConversions = addGlobalTypeConversionsToPropertyMaps(typeConversions, generatedPropertyMaps)
            return TypeMap(sourceClass, targetClass, propertyMapsWithTypeConversions)
        } catch (ex: Exception) {
            throw MappingException("Cannot create type map for $sourceClass and $targetClass. ${ex.message}")
        }
    }

    private fun autoGeneratedPropertyMaps(): Collection<PropertyMap> {
        return targetClass.declaredMemberProperties
                   .filterNot { targetProperty -> userDefinedPropertyMaps.map { it.targetPropertyName }.contains(targetProperty.name) }
                   .mapNotNull { targetProperty ->
                       targetClass.primaryConstructor?.parameters?.firstOrNull { it.name == targetProperty.name }?.let { targetParameter ->
                           sourceClass.declaredMemberProperties.firstOrNull { it.name == targetProperty.name }?.let { sourceProperty ->
                               PropertyMap(
                                   targetProperty = targetProperty,
                                   targetParameter = targetParameter,
                                   sourceResolution = NamedSourceResolution(sourceProperty),
                                   conversion = TypeConversions.noopConverter(sourceProperty.returnTypeClass, sourceProperty.returnType, targetProperty.returnTypeClass)
                               )
                           }
                       }
                   } + userDefinedPropertyMaps
    }

    private fun addGlobalTypeConversionsToPropertyMaps(typeConversions: TypeConversions, propertyMaps: Collection<PropertyMap>): List<PropertyMap> {
        return propertyMaps.map {
            when (it.sourceResolution) {
                is NamedSourceResolution -> {
                    val converter = typeConversions.getConverter(it.sourceResolution.sourceProperty.returnTypeClass, it.targetPropertyClass)
                    if (converter != null) {
                        it.copy(conversion = converter)
                    } else {
                        it
                    }
                }
                else -> it
            }
        }
    }

    fun <T, U, V> propertydMap(kProperty1: KProperty1<U, V>, function: (T) -> V): Any {
        val reflected = function.reflect()
        val ref = reflected as KFunction1<T, V>
        val returnType = ref.returnType
        val params = ref.parameters
        val returnTyper = reflected.returnType
        val paramsr = reflected.parameters.first().type
        return ref.call("") as Any
    }
}